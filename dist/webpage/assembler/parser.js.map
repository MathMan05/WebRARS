{"version":3,"sources":["../../../src/webpage/assembler/parser.ts"],"sourcesContent":["import {instructions, registerNames} from \"../fetches.js\";\n\nconst instnames = new Set(instructions.map((_) => _.name));\nconst regNames = new Set<string>([...registerNames.int.flat(), ...registerNames.float.flat()]);\n\ntype partTypes =\n\t| \"string\"\n\t| \"comment\"\n\t| \"space\"\n\t| \"invalidString\"\n\t| \"parentheses\"\n\t| \"instruction\"\n\t| \"number\"\n\t| \"register\"\n\t| \"variable\"\n\t| \"label\"\n\t| \"char\"\n\t| \"invalidChar\"\n\t| \"directive\"\n\t| \"unknown\";\ntype parsedPart = {content: string; type: partTypes};\n\nfunction identifySegment(str: string): parsedPart {\n\tif (instnames.has(str)) {\n\t\treturn {\n\t\t\ttype: \"instruction\",\n\t\t\tcontent: str,\n\t\t};\n\t} else if (!isNaN(Number(str)) || str === \"NaN\") {\n\t\treturn {\n\t\t\ttype: \"number\",\n\t\t\tcontent: str,\n\t\t};\n\t} else if (regNames.has(str)) {\n\t\treturn {\n\t\t\ttype: \"register\",\n\t\t\tcontent: str,\n\t\t};\n\t} else if (str.startsWith(\"%\")) {\n\t\treturn {\n\t\t\ttype: \"variable\",\n\t\t\tcontent: str,\n\t\t};\n\t} else if (str.endsWith(\":\")) {\n\t\treturn {\n\t\t\ttype: \"label\",\n\t\t\tcontent: str,\n\t\t};\n\t\t//TODO this needs to check if it's a valid directive\n\t} else if (str.startsWith(\".\")) {\n\t\treturn {\n\t\t\ttype: \"directive\",\n\t\t\tcontent: str,\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\ttype: \"unknown\",\n\t\t\tcontent: str,\n\t\t};\n\t}\n}\nfunction* parseLine(str: string) {\n\tconst strings = str.matchAll(\n\t\t/(([\"'])((?:\\\\.|(?!\\2).)*)\\2?)|(#[^\\n]*)|((?:(?!([\"'])(?:(?:\\\\.|(?!\\6).)*)|#).)*)/gm,\n\t);\n\tlet map = strings.map((_) => {\n\t\treturn {\n\t\t\tcontent: _[0],\n\t\t\tmatch: _[0][0] === \"'\" || _[0][0] === '\"',\n\t\t};\n\t});\n\n\tconst rest = map.map(\n\t\t(part: {match?: boolean; content: string; type?: partTypes}): parsedPart | parsedPart[] => {\n\t\t\tif (part.match) {\n\t\t\t\tdelete part.match;\n\t\t\t\tif (part.content.startsWith('\"')) {\n\t\t\t\t\tpart.type = \"string\";\n\t\t\t\t\tif (!part.content.endsWith('\"')) {\n\t\t\t\t\t\tpart.type = \"invalidString\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpart.type = \"char\";\n\t\t\t\t\tif (!part.content.endsWith(\"'\")) {\n\t\t\t\t\t\tpart.type = \"invalidChar\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn part as parsedPart;\n\t\t\t}\n\t\t\tif (part.content.startsWith(\"#\")) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"comment\",\n\t\t\t\t\tcontent: part.content,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst build: parsedPart[] = [];\n\t\t\tfor (const [, match, space] of part.content.matchAll(/([^,()\\s]*)([,()\\s]*)/gm)) {\n\t\t\t\tif (match) {\n\t\t\t\t\tbuild.push(identifySegment(match));\n\t\t\t\t}\n\t\t\t\tif (space) {\n\t\t\t\t\tfor (const thing of space.matchAll(/([\\s,]+)|([()]+)/gm)) {\n\t\t\t\t\t\tif (thing[1]) {\n\t\t\t\t\t\t\tbuild.push({\n\t\t\t\t\t\t\t\ttype: \"space\",\n\t\t\t\t\t\t\t\tcontent: thing[1],\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (thing[2]) {\n\t\t\t\t\t\t\tfor (const char of thing[2].split(\"\")) {\n\t\t\t\t\t\t\t\tbuild.push({\n\t\t\t\t\t\t\t\t\ttype: \"parentheses\",\n\t\t\t\t\t\t\t\t\tcontent: char as \"(\" | \")\",\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn build;\n\t\t},\n\t);\n\tfor (const thing of rest) {\n\t\tif (thing instanceof Array) {\n\t\t\tfor (const item of thing) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t} else {\n\t\t\tyield thing;\n\t\t}\n\t}\n}\nexport {parseLine, parsedPart};\n"],"names":["instructions","registerNames","instnames","Set","map","_","name","regNames","int","flat","float","identifySegment","str","has","type","content","isNaN","Number","startsWith","endsWith","parseLine","strings","matchAll","match","rest","part","build","space","push","thing","char","split","Array","item"],"mappings":"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"}